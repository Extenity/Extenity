#if ExtenityKernel

using System;
using Newtonsoft.Json;

namespace Extenity.KernelToolbox
{

	/// <summary>
	/// Object ID that represents a data blob's unique ID using its Hash. The SHA-256 hashing algorithm used so no hash
	/// collisions are expected between different data blobs.
	///
	/// The OID of a data blob can always be generated by calculating the hash. That also means whenever there are two
	/// identical data blobs, they will both be represented with the same OID. So OID IS NOT designed to represent
	/// instances of data blobs. OID rather represents content of data blobs.
	/// </summary>
	[Serializable]
	[JsonObject(MemberSerialization.Fields)]
	public struct OID
	{
		/// <summary>
		/// Hex representation of OID. The string ensured to contain only uppercase hexadecimal characters.
		/// </summary>
		public readonly string Hash;

		/// <summary>
		/// Creates the OID that represents the object with specified hash. The hash is considered to be globally
		/// unique ID of that object.
		/// </summary>
		/// <remarks>
		/// Only hex characters are allowed. Any lowercase hex characters will be automatically converted to uppercase
		/// characters.
		/// </remarks>
		public OID(string hash)
		{
			if (string.IsNullOrEmpty(hash))
			{
				Hash = "";
			}
			else
			{
				var needsCaseConversion = ValidateHashCharacters(hash);
				if (needsCaseConversion)
				{
					Hash = hash.ToUpperInvariant();
				}
				else
				{
					Hash = hash;
				}
			}
		}

		#region Validation

		public bool IsValid => !string.IsNullOrWhiteSpace(Hash);

		public static readonly OID Invalid = new OID();

		private static bool ValidateHashCharacters(string hash)
		{
			var needsCaseConversion = false;
			for (var i = 0; i < hash.Length; i++)
			{
				var c = hash[i];
				if ((c < '0' || c > '9') &&
				    (c < 'A' || c > 'F'))
				{
					if (c < 'a' || c > 'f')
					{
						throw new Exception("Tried to create Object ID with an unknown character. Hash: " + hash);
					}
					else
					{
						needsCaseConversion = true;
					}
				}
			}
			return needsCaseConversion;
		}

		#endregion

		#region Empty

		private const string EmptyDataHash = "EE";

		public bool IsEmpty => Hash.Equals(EmptyDataHash, StringComparison.Ordinal);

		public static readonly OID Empty = new OID(EmptyDataHash);
		public static readonly byte[] EmptyData = Array.Empty<byte>();

		#endregion

		#region Path

		public string ToPathString()
		{
			return Hash;
		}

		#endregion

		#region Log

		public override string ToString()
		{
			if (string.IsNullOrEmpty(Hash))
			{
				return "[NA]";
			}
			return Hash;
		}

		#endregion
	}

}

#endif
